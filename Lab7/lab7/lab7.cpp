// lab7.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//


/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции

*************************************************************/

#include <tchar.h>
#include <cstdio>
#include <cstdarg>

#include "other.h"
#include <ctime>
#include <stdlib.h>
#include <iostream>
#include <cmath> 
using namespace std;
#define	  stop __asm nop

int _tmain()
{

	//Задание 1. 
	//массивы в качестве аргументов функции.
	//Напишите два варианта функции печати элементов
	//1. встроенного двумерного массива
	//int ar[N][M]; //подумайте - как и где должны быть заданы N и M

	//Замечание:
	// Задать значения элементам массива можно либо с помощью списка инициализации, 
	//// либо с помощью кода 
	
	int ar[N][M] = { 1,2,3,4,5,6,7,8,9,10 }; //подумайте - как и где должны быть заданы N и M
	
	print(ar, sizeof(ar) / sizeof(ar[0]));
	//Вызов функции PrintArray   может выглядеть так:

//	PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр- имя двумерного (!) массива


	//2. динамического двумерного массива (обе размерности вычисляются)
	//Замечание:
	// Задать значения элементам массива можно с помощью кода 
	srand(time(0));
	int N1, M1;
	N1 = 2 * 2;
	M1 = N1 * 2;

	int** p = new int* [N1];

	for (int i = 0; i < N1; i++)
	{
		p[i] = new int[M1];

	}
	for (int i = 0; i < N1; i++)
	{
		for (int j = 0; j < M1; j++)
		{

			p[i][j] = (rand() & 100);
		}
	}
	print_din(p, N1, M1);
	for (int i = 0; i < N1; i++) {
		delete[] p[i];
	}
	delete[] p;
	stop
/////////////////////////////////////////////////////////////////////////////
	//Задание 2.
	//Передача имени встроенного двумерного массива в качестве параметра функции.
			//Напишите две взаимодополняющие друг друга функции:
			//1.  ... DayOfYear(...)
			//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
			//в порядковый день года(возвращаемое значение)
			//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
			// (принимает год и порядковый день года в качестве параметров и должна сформировать
			// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

			//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
			//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
			//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
			//данные приведенного ниже двухмерного массива nDayTab
	int nDayTab[2][12] = {
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год

	//Проверьте работоспособность обеих функций с помощью следующего фрагмента:

	//Вызов функции DayOfYear   может выглядеть так:
	size_t day, month, year;
	// isLeepYear(2000);
	//std::cout<< isLeepYear(year);
	//size_t day = ..., month = ..., year = ...;
	int n = 2;
	day = 28;
	month = 2;
	year = 2001;
	size_t numDay = DayOfYear(day, month, year, nDayTab, n);  //Важно! последний параметр- имя двумерного (!) массива
	std::cout << "day number="<<numDay << std::endl;

	size_t day1 = 0;
	size_t month1 = 0;
	//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
	//...
	//DayOfMonth(numDay, size_t year, nDayTab, n)
	DayOfMonth(numDay,  year, nDayTab, n,   day1,   month1);

	std::cout << "day1=" << day1<<std::endl;  // если 31 декабря то работает.проверить другие даты!!!!!!!!!!!
	std::cout << "month1=" << month1 << std::endl;

	stop
		/////////////////////////////////////////////////////////////////////////////
			//Задание 3.
			//Задание 3а. Функции с переменным числом параметров.
			//Напишите функцию (дана заготовка VarArgs, не использующая
			// макросы), которая принимает переменное число аргументов
			// типа int и выводит на печать число принятых параметров и
			// их значения.
			// Признаком конца списка является нулевое значение.
		
			int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
			VarArgs(nN1,0);
			VarArgs(nN1,nN2,0);
			VarArgs(nN1,nN2,nN3,nN4,nN5,0);
			stop


			
			VarArgs1(nN1, 0);
			VarArgs1(nN1, nN2, 0);
			VarArgs1(nN1, nN2, nN3, nN4, nN5, 0);
			stop
			//Задание 3б. Модифицируйте функцию 3а с помощью макросов
			// va_start, va_arg, va_end
		
		///////////////////////////////////////////////////////////////////
		//Тема "Старые" потоковые функции стандартной библиотеки
		//Задание 4.1 С помощью функции scanf сформирйуте три коэффициента: A,B,C

				int A , B, C;
			printf( "Enter 3 integer numbers\n");
			scanf("%d %d %d", &A, &B, &C);
			printf("A: %d, B: %d, C: %d\n", A, B, C);
			

		
			
		//Задание 4.2. Выведите таблицу значений y=A*x*x + B*x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5
		
			const char* separator = "+-----+---------------+\n";
			printf(separator);
			printf("|  x  |       y       |\n");
			printf(separator);
			for (int i = 0; i < 9; ++i) {
				double x = -2 + i * 0.5;
				double y = A * x * x + B * x + C;
				printf("|%5.1f|%15.2f|\n", x, y);
				printf(separator);
			}
		///////////////////////////////////////////////////////////////////
			//Тема Указатели на функции

			//Задание 5. Указатель на функцию. "Калькулятор".
			//Напишите функции:
			//1)Sum - принимает два значения double и возвращает сумму
			//этих значений
			//2)Sub- принимает два значения double и возвращает разность
			//этих значений
			//3)Mul - *
			//4)Div - /
			//5)а для возведения в степень можете использовать функцию стандартной библиотеки
			//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
			//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
			//		вариантов этой функции, а Вам потребуется сформировать указатель на 
			//		double pow(double, double);

			double a, b;
			double sum=0;
			double sub=0;
			double del=0;
			double mul=0;
			double pow1=0;
			char oper;
			/*char anw;*/

			int inp = 1;
			
			while (inp == 1) {
				std::cout << "Do you want caclucation? Input '1' if you want to continue, or press any key for exit " << std::endl;
				std::cin >> inp;
				if (inp != 1) {
					std::cout << "exit" << std::endl;
					break;
				}
				calc(a, b, oper, &sum, &sub, &del, &mul, &pow1);
			}
			//std::cout << "sum = " << sum << "\n";
			
			
			//Предоставьте пользователю	следующую возможность:
			//пока пользователь хочет пользоваться услугами Вашего калькулятора,
			//он может вводить два значения и знак операции
			//а Вы выводите результат. Результат получаете посредством вызова
			//соответствующей Вашей функции по указателю.
			//Предусмотрите возможность ввода непредусмотренного знака операции

	
		///////////////////////////////////////////////////////////////////
			//Задание 6. Указатель на функцию в качестве аргумента.
			//Дана заготовка функции сортировки любых объектов - Sort.
			//Функция принимает следующие параметры:
			//1) указатель на первый сортируемый элемент
			//2) количество сортируемых элементов
			//3) размер элемента в байтах
			//4) указатель на функцию перестановки элементов
			//5) указатель на функцию сравнения элементов1
		
			const int size = 20;
			int nAr[size];     //массив для сортировки
			srand((unsigned int)time(0));
			for (int i = 0; i < size; i++) {
				nAr[i] = rand() % 100;
			}
			int mm = sizeof(nAr) / sizeof(nAr[0]);
			print_1(nAr, mm);
			Sort(reinterpret_cast<char*>(&nAr[0]), mm, sizeof(int), SwapInt, CmpInt);
			print_1(nAr, mm);
			//6a. Напишите функцию перестановки двух целых значений -
			// SwapInt, которая принимает два void указателя и 
			//меняет значения местами

			//Напишите функцию сравнения двух целых значений -
			// CmpInt, которая принимает два void указателя и
			//возвращает int результат сравнения: 
			//<0 - первый элемент меньше, чем второй
			//=0 - равны
			//>0 - первый элемент больше, чем второй
			/*
				int nAr[]=...	//массив для сортировки

				//Печать исходного массива

				//Вызов сортировки
				int nTotal=...			//количество элементов в массиве
				Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

				//Печать результатов сортировки

				stop
			*/
			/*
			//Задание 6б. По аналогии с 6а создайте вспомогательные
			//функции - SwapDouble и CmpDouble и вызовите функцию Sort
			//для сортировки массива вещественных значений.
			*/
			double nArr[size];     //массив для сортировки
			srand((unsigned int)time(0));
			std::cout << '\n';
			for (int i = 0; i < size; i++) {
				nArr[i] = (rand() % 101 - 50) / 10.0;
			}
			int mmm = sizeof(nArr) / sizeof(nArr[0]);
			//print_1(nArr, mmm);
			for (int i = 0; i < mmm; i++)
			{

				std::cout << nArr[i] << ", ";


			}
			std::cout << '\n';
			SortDouble(reinterpret_cast<char*>(&nArr[0]), mmm, sizeof(double), SwapDouble, CmpDouble);
		//	print_1(nArr, mmm);
			for (int i = 0; i < mmm; i++)
			{

				std::cout << nArr[i] << ", ";


			}
			std::cout << '\n';
			//Задание 6в*. По аналогии с 6а создайте вспомогательные
			//функции - SwapStr и CmpStr и вызовите функцию Sort
			//для сортировки массива указателей на строки.

			const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En"};
			int mmmm = sizeof(arStr) / sizeof(arStr[0]);

			//Замечание:
			for (int i = 0; i < mmmm; ++i) {
				printf("%s ", arStr[i]);
			}
			//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива,
				Sort(reinterpret_cast<char*>(&arStr[0]), mmmm, sizeof(char*), SwapStr, CmpStr);
				std::cout << "after sort" << std::endl;
				for (int i = 0; i < mmmm; ++i) {
					printf("%s ", arStr[i]);
				}




			///////////////////////////////////////////////////////////////////
				
				//Задание 7. Массивы указателей на функцию.
				//Напишите несколько функций вида
				//const char* GetString1();
				//const char* GetString2();
				//const char* GetString3();
				//const char* GetString4();
				//const char* GetString5();

				//		...., каждая из функций возвращает указатель на свою строку
				//(подумайте - какой адрес Вы имеете право возвращать из функции)

				// Вам предоставлен код этих функций.
				//Подумайте:
				//1) все ли они корректны, если нет, то как исправить некорректность
				//2) может быть требуются какие-то дополнительные действия

				//Объявите и проинициализируйте массив указателей на функции
				//GetString1,GetString2...
				//Введите номер функции, которую Вы хотите вызвать:
					int nn=2;
					const char* (*GetAr[])() = { GetString1,GetString2,GetString3,GetString4,GetString5 };

				

				//Вызовите функцию
				//char  res = *GetAr[nn]();

				//Распечатайте результат

				//std::cout << "result massiv of func poiners:" << res << std::endl;
					printf("\nPointers to functions. Enter id (1, 2 of 3,4,5) of function to call.\n");
					scanf("%d", &n);
		
				if (n > 0 && n < 4) {
					printf(GetAr[n - 1]());
				}
				else {
					printf("There is no function with this id.");
				}
				printf("\n");

				////////////////////////////////////////////////////////////////////////////
					//Задание 8*.
					//Создайте одномерный массив (размерность вычисляется в процессе
					//выполнения программы), заполните его значениями.
					//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
					//что такого значения в массиве еще нет. 
					//Подсказка: при этом размер  массива должен увеличиться!
					//Для проверки напишите функцию, которая выводит значения всех элементов на экран
					// 
					// 
					// 
					// 
					// 
					// 
				unsigned int Nn;
				Nn = 10;
				int* pn=new int[Nn];
				srand((unsigned int)time(0));
				for (int i = 0; i < Nn; i++) {
					pn[i] = rand() % 100;
				}
				print_1(pn, Nn);
				int NN = 0; // сюда записываем введенное значение
				std::cout << "Enter int" << std::endl;
				std::cin >> NN;
				int* new_mas;
				new_mas = insert(pn, Nn, NN);
				///////////////////////////////////////////////////////////////////////////
			//	/*********************   Дополнительное задание   ****************************************************
				//Задание 9 (*)
				// Выполните задание 8 по курсовой работе
				// описание задания находится в файле "Задание (игра Змейка)_8 (двумерный динамический массив поля)_3.docx"
				//*****************************************************************************************************
				print_1(new_mas, Nn+1);

					return 0;
				}//main


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
