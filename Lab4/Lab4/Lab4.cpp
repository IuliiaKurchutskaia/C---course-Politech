/*************************************************************
	Практическое занятие №4. Встроенные массивы.
							Простейшие алгоритмы сортировки и поиска.

*************************************************************/

#include <cstdlib>
#include <ctime>
#include <iostream>

#define	  stop __asm nop





int main()
{

	/*
//Задания, помеченные * не являются обязательными. Но выполнение их крайне желательно!!!

	///////////////////////////////////////////////////////////////
	//			Указатели (продолжение)
	///////////////////////////////////////////////////////////////

			//Задание 1. Модификатор const.
			//В каждом из заданий объявите указатель требуемого вида.
			//Посредством каждого указателя попробуйте:
			//1) получить значение по адресу
			//2) записать новое значение по адресу
			//3) модифицировать указатель
	//Замечания:
	//1.операторы явного преобразования типа использовать не следует
	//2.если компилятор не позволяет выполнить операцию, то комментируйте эту строку с пояснением


		//Задание 1a. Указатель является константой.
	int x = 5;
	int* const y = &x;

	int b = *y;
	*y = 23;
	//y++;





	//Задание 1б. Указываемое значение является константой.

	int x = 5;
	const int* y = &x;
	int b = *y;
	//*y = 23;
	y++;
	stop



		// *******************************************************


				//Задание 1в. И указатель, и указываемое значение
				//являются константами.
		int x = 5;
	int  const* const  y = &x;
	int b = *y;
//	*y = 23;
	//y++;
	stop

		//*******************************************************


				//Задание 1г. Указатель на переменную, объявленную с
				//ключевым словом const.
	//	const int nN = 1;
	const int* y = &nN;
	int b = *y;
	*y = 23;
	y++;;



	//Объявите указатель и проинициализируйте его выражением - &nN
	const  int* y = &nN;
	int b = *y;
	*y = 23;
	y++;
	stop



			//Задание 1д. const  и void-указатель.
	{
		//1) Что нужно сделать для того, чтобы следующее закомментированное выражение
		//стало корректным?
	//	const int n = 1;
	//	 void const* y =&n;

		// int b = *y;
		// *y = 23;
		// y++;


	//	 std::cout << y << std::endl;
		 //2) как получить значение посредством  void* ?

	}
		//*******************************************************

			//Задание 1е. Объявите указатель на тип char и проинициализируйте
			//его адресом строкового литерала. Присвойте переменной типа char значение
			//любого элемента строки.
			//Проверьте - возможно ли присвоить какое-либо значение по адресу,
			//задаваемому указателем?


	const char* p = "gSggg";
	char b = p[0];
	//p[0] = 'k';
	p++;


	stop


		// //*******************************************************
			//Задание 2. Явное преобразование указателя.
			//Иногда возникает необходимость одни и те же данные интерпретировать по-разному,

			//например, целое можно представить как совокупность четырех
			//байтов и работать с каждым байтом по отдельности. Для этого
			//нужно иметь возможность "указывать" как на целое, так и на байт.

			//Следовательно, возникает необходимость явного преобразования указателя.

			//Подсказка: для правильной интерпретации этого задания воспользуйтесь
			//возможностями отладчика представлять данные в интересующем
			//Вас виде (в данном случае - в шестнадцатеричном) - для
			//этого используйте правую клавишу мыши,находясь в окне

			//переменных и изменяйте пункт - Hexadecimal display !!!!!!!!!!!!!!!!!


		unsigned int nObject5 = 0x55667788;
	unsigned int* pnObject5 = &nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание на сообщение компилятора
	//- он не считает преобразование "легальным" (безопасным)

	unsigned char* pucObject5;

	//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)

	pucObject5 = reinterpret_cast<unsigned char*>(pnObject5);	//а такое
	//преобразование - целиком на совести программиста.
	//Его можно применять, только четко представляя себе
	//результат преобразования (2)

//Откомментируйте (!) следующие строчки следующим образом:
// сс=..., 	pucObject5 - изменился? 	*pucObject5=...

	char cc = *(pucObject5++);	// сс=0x88 '€', 	pucObject5 - изменился? 'w'	*pucObject5=0x77 'w'
	cc = (*pucObject5)++;		//сс='w', pucObject5 - изменился? 0x78 'x'	*pucObject5=0x78 'x'

	cc = ++ * (pucObject5);		//0x79 'y' у всех
	cc = *(++pucObject5);		// 			cc	0x66 'f'	char		0x66 'f'	unsigned char    		*pucObject5	0x66 'f'	unsigned char


	stop

		///////////////////////////////////////////////////////////////
		//			Встроенные массивы
		///////////////////////////////////////////////////////////////

			//Задание 3.
			//Имеется одномерный встроенный массив, проинициализированный при объявлении
			//Отсортируйте массив по возрастанию значений.
			//Используйте "пузырьковую" сортировку
			// Правильность решения проверьте с помощью отладчика

	{
		int ar[] = { 5, 4, 7,  8, 1, 2, 6, 0, 10, 12, 77, 11,
					  6, 8, 33, 21, 1, 2, 3, 4 };

	int n = sizeof(ar) / sizeof(int);
	for (int i = 0; i < n - 1; i++)
	{
		int min = i; {
			for (int j = i + 1; j < n; j++) {
				if (ar[j] < ar[min]) min = j;
			}
			int tmp = ar[min];
			ar[min] = ar[i];
			ar[i] = tmp;
		}
	}
	stop

	}


		// *******************************************************
			//Задание 4
			//в)Инициализация массива строковыми литералами:
			//Объявите одномерный массив УКАЗАТЕЛЕЙ и проинициализируйте его СТРОКОВЫМИ литералами .
			//Выведите  массив на печать.

	 const char* ar[] = {"bannana", "apple","orange"};
	 for (int i = 0; i < 3; i++)
	 {

		 std::cout << ar[i] << std::endl;
	 }



		// *******************************************************
			//Задание 5.
			//a) Объявите одномерный неинициализированный массив ( размером N)
			//Задайте значения элементов с помощью генератора случайных чисел.

	 double ar[10];

			//Подсказка 1: для генерации случайных чисел используйте функцию
			//стандартной библиотеки - rand() (<cstdlib>)
			// int tmp= rand(); // получим случайное значение в диапазоне от 0 до RAND_MAX
				//значение RAND_MAX задано в файле <stdlib.h>  и равно  0x7fff

			//если Вам требуется задать иные границы диапазона при генерации случайного числа,
			//то это можно сделать так:
			//v1 = rand() % 100;         // v1 в диапазоне 0 - 99
			//v2 = rand() % 100 + 1;     // v2 в диапазоне 1 - 100
			//v3 = rand() % 30 + 1985;   // v3 в диапазоне 1985-2014

			//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
			//чисел являются "псевдослучайными", то есть при двух последовательных запусках
			//приложения Вы получаете две одинаковые последовательности значений.
			//Для того чтобы генерируемые "случайные" значени я были разными при каждом
			//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
			//и time() (<ctime>).
			//Функция srand() осуществляет "привязку" начала генерации к указанному в качестве параметра значению.
			//Функция time() задает эту точку отсчета, считывая текущее время
			//srand( time( 0 ) );
		//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)

		
	srand(time(0));
	int ar[10];
	int n = sizeof(ar) / sizeof(int);
	for (int i = 0; i < n; i++)
	{
		ar[i] = rand() % 31; //в интервале[0; 30]
		// int R = 10 + rand() % (15 – 10 + 1);  // 
		// arr[i] = R;
		std::cout << ar[i];
	}



	

	
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n-1; j++) {
			if (ar[j] > ar[j + 1]) {
				int b = ar[j]; // создали дополнительную переменную
				ar[j] = ar[j + 1]; // меняем местами
				ar[j + 1] = b; // значения элементов
			}
		}
	}




std::cout << "\n" << std::endl;
for (int i = 0; i < n; i++)
{
	
	std::cout << ar[i] ;
}




			//б) Выведите массив на печать

			//в)Отсортируйте массив по убыванию значений.
			//Используйте сортировку "выбором"  BOBBLE

		//

		// *******************************************************

			//Задание 6.
			//Объявите встроенный одномерный массив, состоящий из N элементов целого типа.
			//Напишите фрагмент кода, который вводит целые числа с помощью
			//потока ввода в объявленный Вами массив, каждый раз ( на каждой итерации!)
			//упорядочивая полученное значение по возрастанию.
			//Для проверки выводите массив на консоль на каждой итерации`


		int ara[15] = {0,0,0,0,0,0,0,0,0,0};

			 int n = sizeof(ara) / sizeof(int);

			 int v;


			 for (int i = 1; i < n; i++)//Cчитаем, что нулевой элемент "упорядочен"

			 {
				 std::cout <<"\n"<< "Input element" << std::endl;

				 std::cin >> v;
				 int tmp = v;//запомнили значение текущего

				 //нашли "куда" вставлять

				 int j = 0;

				 for (; j < i; j++)//цикл по j
				 {

					 if (ara[j] > tmp) break;//вставлять перед j-тым

				 }

				 //сдвинули от i до j на одну позицию вправо

				 for (int k = i; k > j; k--)//начинаем сдвигать "с справого", так как i-тый свободен

				 {

					 ara[k] = ara[k - 1];

				 }


				 ara[j] = tmp; //вставили сохраненное значение на освободившееся мест
				 for (int i = 0; i < sizeof(ara) / sizeof(int); i++)
				 {

					 //std::cout << "ara[i]=" << ara[i] << std::endl;
					 std::cout << ara[i]<<" ";
				 }
			 }





		// *******************************************************
			//Задание 7.

			//Простой поиск.
			//Модифицируйте предыдущее задание следующим образом:
			//очередное введенное значение помещается в массив только при условии,
			//что там еще такого нет (то есть дубли игнорируются)

int ara[5] = { 0,0,0,0,0};

int n = sizeof(ara) / sizeof(int);

int v;
bool f = true;

for (int i = 0; i < n; i++)//Cчитаем, что нулевой элемент "упорядочен"

{
METKA: {
	std::cout << "\n" << "Input element" << std::endl;

	std::cin >> v;
	int tmp = v;//запомнили значение текущего

	//нашли "куда" вставлять

	int j = 0;

	for (; j < i; j++)//цикл по j
	{

		if (ara[j] > tmp) break;//вставлять перед j-тым
		else if (ara[j] == tmp) {
			std::cout << "Enter another number! It already exists!" << ' ';
			std::cout << std::endl;
			goto METKA;
		}

	}
	if (f) {
		for (int k = i; k > j; k--)//начинаем сдвигать "с справого", так как i-тый свободен

		{

			ara[k] = ara[k - 1];

		}


		ara[j] = tmp; //вставили сохраненное значение на освободившееся мест

	}
	for (int i = 0; i < n; i++)
	{

		//std::cout << "ara[i]=" << ara[i] << std::endl;
		std::cout << ara[i] << " ";
	}

	}

}




		// *******************************************************
			//Задание 8
			//Объявите одномерный встроенный массив элементов типа char.
			//Сформируйте значения элементов массива с помощью генератора случайных
			//чисел таким образом, чтобы в массиве были только символы '*' и '_'

			//"сдвиньте звездочки" в начало массива, например:
			//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
			//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
			//и распечатайте массив
		//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)

			char  ach[20];
			srand(time(0));
			char a = '*';
			char b = '_';

			int n = sizeof(ach) / sizeof(char);
			for (int i = 0; i < n; i++)
			{
				int R;
				R = rand() % 100;


				ach[i] = R&1?a: b;
				std::cout <<" '" << ach[i] << "',";
			}


			for (int i = 0; i < n - 1; i++)
			{
				int min = i; {
					for (int j = i + 1; j < n; j++) {
						if (ach[j] < ach[min]) min = j;
					}
					int tmp = ach[min];
					ach[min] = ach[i];
					ach[i] = tmp;

				}

			}

			std::cout << "\n";
			for (int i = 0; i < n; i++)
			{

				std::cout << " '" << ach[i] << "',";
			}


		// *******************************************************
			//Задание 9
			//объявите одномерный встроенный массив  из N элементов и проинициализируйте его.
			//а) сдвиньте все элементы массива вправо на 1 позицию
			//б) (Циклическая перестановка). Сдвиньте все элементы массива вправо на 1 позицию ,
			//но последний элемент не должен быть утерян. Его следут переместить в начало.
			//например,  { 5, 2, 11, 4, 23, 9 } ->  {9, 5, 2, 11, 4, 23 }

			//в)(Кольцевой буфер) выведите массив на печать, циклически "сдвинув" элементы вправо на 1 позицию.
			//При решении задачи не следует перемещать элементы массива, а надо использовать кольцевой буфер.
			// Одномерный массив можно "свернуть" в кольцо и считать, что за последним элементом следует начальный и
			// потом установить "новое" начало массива.

		int arr[] = { 1, 2, 3, 4, 5, 6 };
			int n = sizeof(arr) / sizeof(int);

		for (int i = arr[n-2]; i >= 0; i--)
		{
			arr[i + 1] = arr[i];
		}


		for (int i = 0; i < n-1; i++)
		{

			std::cout << " '" << arr[i] << "',";
		}


		//--*******************************
		int arr[] = { 1, 2, 3, 4, 5, 6 };

			int last = arr[5];

		for (int i = arr[n-2]; i >= 0; i--)
		{
			arr[i + 1] = arr[i];
		}

			arr[0] = last;

		for (int i = 0; i < n-1; i++)
		{

			std::cout << " '" << arr[i] << "',";
		}
*/

/*
		int arr[] = { 1, 2, 3, 4, 5, 6 };
		int n = sizeof(arr) / sizeof(int);
		int shift = 1;
		for (int i = 0; i < n; i++)
		{

				std::cout << " '" << arr[(shift-i+n)%n] << "',";//сдвиг вправо на единицу
		}


		*/



//srand(time(0));
//int ar[10];
//int k = sizeof(ar) / sizeof(int);
//for (int i = 0; i < k; i++)
//{
//	ar[i] = rand() % 31; //в интервале[0; 30]
//	// int R = 10 + rand() % (15 – 10 + 1);  // 
//	// arr[i] = R;
//	std::cout << ar[i];
//}
//
//for (int i = 1; i < k; ++i)
//{
//	for (int r = 0; r < k - i; r++)
//	{
//		if (ar[r] < ar[r + 1])
//		{
//			// Обмен местами
//			int temp = ar[r];
//			ar[r] = ar[r + 1];
//			ar[r + 1] = temp;
//		}
//	}
//}
//
//
//std::cout << "\n";
//
//
//for (int i = 0; i < k; i++)
//{
//	
//
//	std::cout << ar[i] << ' ';
//}



//
//int ara[5];// = { 0,0,0,0,0,0,0,0,0,0 };
//
//int n = sizeof(ara) / sizeof(int);
//
//int v;
//
//
//for (int i = 0; i < n; i++)//Cчитаем, что нулевой элемент "упорядочен"
//
//{
//	std::cout << "\n" << "Input element" << std::endl;
//
//	std::cin >> v;
//	int tmp = v;//запомнили значение текущего
//
//	//нашли "куда" вставлять
//
//	int j = 0;
//
//	for (; j < i; j++)//цикл по j
//	{
//
//		if (ara[j] > tmp) break;//вставлять перед j-тым
//
//	}
//
//	//сдвинули от i до j на одну позицию вправо
//
//	for (int k = i; k > j; k--)//начинаем сдвигать "с справого", так как i-тый свободен
//
//	{
//
//		ara[k] = ara[k - 1];
//
//	}
//
//
//	ara[j] = tmp; //вставили сохраненное значение на освободившееся мест
//	for (int h = 0; h <= i; h++)
//	{
//
//		//std::cout << "ara[i]=" << ara[i] << std::endl;
//		std::cout << ara[h] << " ";
//	}
//}
//
//stop


//
//
//int ara[5];// = { 0,0,0,0,0 };
//
//int n = sizeof(ara) / sizeof(int);
//
//int v;
//bool f = false;
//
//for (int i = 0; i < n; i++)//Cчитаем, что нулевой элемент "упорядочен"
//
//
//{
//	f = false;
//	//METKA: {
//	std::cout << "\n" << "Input element" << std::endl;
//
//	std::cin >> v;
//	int tmp = v;//запомнили значение текущего
//
//	//нашли "куда" вставлять
//
//	int j = 0;
//
//	for (; j < i; j++)//цикл по j
//	{
//
//		if (ara[j] > tmp) break;//вставлять перед j-тым
//		else if (ara[j] == tmp) {
//			std::cout << "Enter another number! It already exists!" << ' ';
//			std::cout << std::endl;
//			f = true;
//			//goto METKA;
//		}
//
//	}
//
//
//		if (f) {
//			--i;
//			continue;
//
//		}
//
//		for (int k = i; k > j; k--)//начинаем сдвигать "с справого", так как i-тый свободен
//
//		{
//
//			ara[k] = ara[k - 1];
//
//		}
//
//
//		ara[j] = tmp; //вставили сохраненное значение на освободившееся мест
//
//	
//	for (int i = 0; i < sizeof(ara) / sizeof(int); i++)
//	{
//
//		//std::cout << "ara[i]=" << ara[i] << std::endl;
//		std::cout << ara[i] << " ";
//	}
//
//
//}
//



	// *******************************************************
			//Задание 8
			//Объявите одномерный встроенный массив элементов типа char.
			//Сформируйте значения элементов массива с помощью генератора случайных
			//чисел таким образом, чтобы в массиве были только символы '*' и '_'

			//"сдвиньте звездочки" в начало массива, например:
			//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
			//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
			//и распечатайте массив
		//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)

char  ach[20];
srand(time(0));
char a = '*';
char b = '_';
int n = sizeof(ach) / sizeof(char);
int l = 0;
int r = n - 1;



for (int i = 0; i < n; i++)
{
	int R;
	R = rand() % 100;


	ach[i] = R & 1 ? a : b;
	std::cout << " '" << ach[i] << "',";
}


for (int i = 0; i < n-1; i++)
{
	if (l < r) {
		if (ach[l] == a) {
			l++;
		}
		else if (ach[r] == b) {
			r--;
		}
		else if (l >= r) {
		
			continue;
		}
		else {
			int temp = ach[l];
			ach[l] = ach[r];
			ach[r] = temp;
			l++;
			r--;
		}
	}
	
	continue;
	

}

std::cout << "\n";
for (int i = 0; i < n; i++)
{

	std::cout << " '" << ach[i] << "',";
}








		// *****************************************************************************************************************
			//Задание 10 (*)
			//алгоритм "тасования колоды"
			//объявите одномерный встроенный массив  из N элементов и 
			// заполните  его неповторяющимися числами из заданного отрезка 
			//натурального ряда, расположенными в случайном порядке
		//(Подсказки в файле Алгоритмы для лабораторной работы_4.pdf)
		//Алгоритм:
		//Массив  A [N] инициализируется последовательными значениями из отрезка, например [0,N-1]
		//index=N-1, где index- максимальное значение индекса.

		//В цикле по index выполняется перемешивание значений:
		//	1. Генерируется случайное число  R из отрезка [0, index]
		//	2. Выполняется обмен значений A[index]  и  A[R]
		//	3. index=index -1
		//	4. Если index==0, то конец
		//	5. Переход к шагу 1    

			//Для того, чтобы выполнять это задание было интереснее, можно воспользоваться следующим массивом
			// массив текстовых эквивалентов  достоинства карт
		const char* cards[] = { " 2\5", " 3\5", " 4\5", " 5\5", " 6\5", " 7\5", " 8\5", " 9\5", "10\5", " J\5", " Q\5", " K\5", " A\5",
			" 2\4", " 3\4", " 4\4", " 5\4", " 6\4", " 7\4", " 8\4", " 9\4", "10\4", " J\4", " Q\4", " K\4", " A\4",
			" 2\3", " 3\3", " 4\3", " 5\3", " 6\3", " 7\3", " 8\3", " 9\3", "10\3", " J\3", " Q\3", " K\3", " A\3",
			" 2\6", " 3\6", " 4\6", " 5\6", " 6\6", " 7\6", " 8\6", " 9\6", "10\6", " J\6", " Q\6", " K\6", " A\6",
	};
/*
		int n = sizeof(cards) / sizeof(char);
		const char *tmp;
		for (int i = n-1; i >= 0; i--)
		{
			int R;
			R = rand() % i;
			tmp = cards[i];
			cards[R] = tmp;
			cards[i] = cards[R];
			i--;

		}

		for (int i = 0; i < n; i++)
		{

			std::cout << " '" << cards[i] << "',";
		}

*/



	//*********************   Дополнительное задание   ****************************************************
	//Задание 11 (*)  
	// Выполните задания 3 и 4 по курсовой работе 
	// описание заданий находится в файлах "Задание (игра Змейка)_3 (одномерные массивы)_3.docx" и 
	// "Задание (игра Змейка)_4 (+еда)_3.docs"
	// Каждое задание выполняется в отдельном проекте
	// Рекомендация:
	// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
	//*****************************************************************************************************

		; ; }