#include <istream>
/*************************************************************
	Практическое занятие 1. Встроенные многомерные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <stdio.h>

#include <string.h>
#include <cstdlib>
#include <ctime>

#define	  stop __asm nop
using namespace std;
int main()
{

	///////////////////////////////////////////////////////////////
	//			Встроенные  многомерные массивы                               //
	///////////////////////////////////////////////////////////////
	/*
	//Задание 1.
	////а)Объявите трехмерный N*M*K массив и сформируйте указанные
	////значения элементов следующим образом:
	////(проинициализируйте массив при определении)
	////						  |------------|
	////  					/ |	5  5  5  5 |
	////					   |------------|5 |
	////  				 / | 4  4  4  4 |5 |
	////				    |------------|4 |__|
	////			      / | 3  3  3  3 |4 |/
	////    			 |------------|3 |__|
	////			   / | 2  2  2  2 |3 | /
	////			  |------------|2 |__|
	////			  | 1  1  1  1 |2 | /
	////			  | 1  1  1  1 |__|
	////			  | 1  1  1  1 | /
	////			  |____________|


	//*/
	//const int N = 5, M = 3, K = 4;

	//int ar[N][M][K] = {
	//	{{1,1,1,1}, {2,2,2,2}, {3,3,3,3}},
	//	{{4,4,4,4},{5,5,5,5}}
	//};
	///*
	////б) объявите трехмерный N*M*K неинициализированный массив, 
	//// присвойте значения элементам с помощью кода
	////						  |------------|
	////  					/ |	5  5  5  5 |
	////					   |------------|5 |
	////  				 / | 4  4  4  4 |5 |
	////				    |------------|4 |__|
	////			      / | 3  3  3  3 |4 |/
	////    			 |------------|3 |__|
	////			   / | 2  2  2  2 |3 | /
	////			  |------------|2 |__|
	////			  | 1  1  1  1 |2 | /
	////			  | 1  1  1  1 |__|
	////			  | 1  1  1  1 | /
	////			  |____________|


	////Рекомендация: В качестве размерностей массива лучше указать N, M, K,
	////а не задавать их жестко.*/
	//int arr[N][M][K];
	//for (int i = 0; i < N; i++) {
	//	for (int j = 0; j < M; j++) {
	//		for (int k = 0; k < K; k++) {
	//			arr[i][j][k] = (i + 1);// +(j + 1) + (k + 1);
	//		}
	//	}
	//}

	//for (int i = 0; i < N; i++) {
	//	for (int j = 0; j < M; j++) {
	//		for (int k = 0; k < K; k++) {
	//			std::cout<<arr[i][j][k] << ' ';
	//		}
	//		std::cout << std::endl;
	//	}
	//	std::cout << std::endl;
	//}

	//stop


	//	//Средствами отладчика проверьте правильность Вашего решения.

	//	//Или выведите содержимое массива на печать.
	//	// Удобно выводить построчно каждый слой  массива и
	//	//после каждого слоя пропускать строку для того, чтобы отделить один слой от другого

	//	//в) найдите сумму элементов массива, объявленного в пункте б) 
	//	//Подумайте, как это сделать эффективно.
	////	int(*p)[M][K]=arr;
	////int *sum;
	////for (int j = 0; j < M; j++) {
	////	for (int k = 0; k < K; k++) {
	////		sum = +(p)[j][k];
	////	}
	////	
	////}
	////std::cout << *sum
	//	int sum = 0;
	//	for (int i = 0; i < N; i++) {
	//		for (int j = 0; j < M; j++) {
	//			for (int k = 0; k < K; k++) {
	//				sum = sum+arr[i][j][k];
	//			}
	//			
	//		}
	//		
	//	}
	//	std::cout << sum << std::endl;
	////г) объявите трехмерный N*M*K  массив и проинициализируйте его при определении:
	////				     |--------|
	////			       / |3  0  0 |
	////      		 |---------|0 |
	////    		   / | 2  0  0 |0 |
	////			  |---------|0 |__|
	////			  | 1  0  0 |0 | /
	////			  | 0  0  0 |__|
	////			  | 0  0  0 | /
	////			  |_________|

	//	int ar1[3][3][3];// = { {1}, {2}, {3} };

	//
	//	for (int i = 0; i < 3; i++) {
	//		for (int j = 0; j < 3; j++) {
	//			for (int k = 0; k < 3; k++) {
	//				std::cout << ar1[i][j][k] << ' ';
	//			}
	//			std::cout << std::endl;
	//		}

	//		std::cout << std::endl;
	//	}
	//	stop

	//		//д) Инициализация массивов строковыми литералами:
	//		//Объявите и проинициализируйте строковыми литералами два массива:
	//		//двумерный массив символов и одномерный массив указателей на char. 
	//		//Поясните разницу в использовании элементов таких массивов.

	// char arr1[][6] = { "i", "love", "c++" };//компилятор в стат памяти выделяет память для массиива3*6*sizeofchar.копирует содержание стр.литератов в строки массива.
	//const char *arr_1[] = { "i", "love", "c++" };//в стат памяти выделяет место для хранения строк, присваивает каждому элементу значение, равное адресу начала литерала.
	/////////////////////////////////////////////////////////////////////
	//Задание 2.
	//С помощью данной заготовки напишите программу,которая:
	//вводит строки с клавиатуры с помощью cin>>...

	//for (int i = 0; i < N; i++) {
	//	for (int j = 0; j < M; j++) {
	//		for (int k = 0; k < K; k++) {
	//			arr[i][j][k] = (i + 1);// +(j + 1) + (k + 1);
	//		}
	//	}
	//}
	//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 10*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение всего массива (больше свободных строк нет);

	//То есть:
		//a) можно заполнять весь массив полностью (не забудьте подсказать, сколько элементов в массиве)
		//б) можно заполнять массив частично, до тех пор, пока пользователь не ввел строку "*".
		//Например:вводим строки (строки с пробелами не задаются, т.к. пробелы являются разделителями):
		//"Hello"
		//"Ok"
		//"*"
	//Выполните сортировку строк в алфавитном порядке. 
	// 
	//Пояснение: крайне не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти ( в нашем случае перемещать (копировать) строки)
	//Намного эффективнее завести массив указателей на соответствующие строки 
	//и перемещать только указатели на начало строк (массивов символов).
	//Вопрос: При таком способе что будет  отсортировано?

	//Подсказка: для лексикографического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string.h>.
	
	//int strcmp(char const* _Str1, char const* _Str2);

	// далее Вам предлагается алгоритм, следуя которому, Вы сможете решить задачу.
	//{

		//Определите необходимые значения как константы
		//STOP_STRING  -  "*"	//признак "прекратить ввод"
		//M  -  80	//максимальный размер одной строки
//		//N  -  10	//максимальное количество строк в массиве
//	char STOP_STRING = '*' ;	//признак "прекратить ввод"
//	const int Mn = 80;	//максимальный размер одной строки
//	const int Nn = 5;	//максимальное количество строк в массиве
//	char probel = ' ';
//	
//		//Объявите двухмерный массив с именем cBuffer типа char и
//		// размерностью N*M
//	char cBuffer[Nn][Mn];
//
//		//Объявите массив (с именем cPointers) указателей на строки
//		//размерностью N
//	 char* cPointers[Nn];
////	 char* tmp[Nn];
//	//int strcmp(char const* _Str1, char const* _Str2);
//		//Цикл ввода строк:
//		//а) выведите приглашение для ввода
//	std::cout << "input word"<<std::endl;
//
//		//б) пока не введена строка STOP_STRING или не заполнен весь массив
//	//char word;
//
//		//ввод строки в массив cBuffer:
//	//int strcmp(char const* _Str1, char const* _Str2);
//	int ind = 0;
//	for (int i = 0; i < Nn; i++) {
//
//		std::cin >> cBuffer[i];
//		if (cBuffer[i][0] == STOP_STRING) {
//			std::cout << "break input" << std::endl;
//			std::cout <<  std::endl;
//			break;
//		}
//		
//		cPointers[i] = cBuffer[i];
//		ind++;
//	}
//
//	std::cout << "Our array:" << std::endl;
//	for (int i = 0; i < ind; i++) {
//
//
//		std::cout << cBuffer[i] << std::endl;
//
//		//std::cout << std::endl;
//
//
//	}
//	//stop
//		//если введена строка - признак окончания, то выйти из цикла
//
//		//Присвойте элементу массива cPointers с индексом nIndex
//		//указатель на строку с номером nIndex в массиве cBuffer
//		for (int i = 0; i < ind; i++) {
//			for (int j = 0; j < ind - 1; j++) {
//				if (cPointers[j][0] > cPointers[j + 1][0]) {
//					char * tmp = cPointers[j];
//					cPointers[j] = cPointers[j + 1];
//					cPointers[j + 1] = tmp;
//				}
//				
//			}
//	
//
//		}
//	
//	std::cout << std::endl;
//	for (int i = 0; i < ind; i++) {
//
//		std::cout << cPointers[i] << std::endl;
//
//
//	}
//
//	stop

		//Выдать диагностику о том, что прием строк завершен.

		//Распечатайте содержимое массива

		//Теперь сортируем строки:

	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа

	//Распечатайте содержимое массива после сортировки

//	}
	//////////////////////////////////////////////////////////////////////////////

	//Задание 3*. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	{
		const size_t N = 4, M = 3, K = 4;
		//// 
		double dArray[N][M][K];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				for (int k = 0; k < K; k++) {
					dArray[i][j][k] = (i + 1);// +(j + 1) + (k + 1);
				}
			}
		}
		////	double dArray[N][M][K]; //так, как показано на рисунке и напишите фрагмент
			// 
			//кода, который меняет местами значения элементов четных
			//и нечетных слоев:
			//	было:
			//					    |-----------|
			//  				  / |4  4  4  4 |
			//				     |-----------|4 |
			//			       / |3  3  3  3 |4 |
			//    			 |------------|3 |__|
			//			   / | 2  2  2  2 |3 | /
			//			  |------------|2 |__|
			//			  | 1  1  1  1 |2 | /
			//			  | 1  1  1  1 |__|
			//			  | 1  1  1  1 | /
			//			  |____________|

			//	стало:	

			//					   |------------|
			//  				  /| 3  3  3  3 |
			//				     |-----------|3 |
			//			       / |4  4  4  4 |3 |
			//    			 |------------|4 |__|
			//			   / | 1  1  1  1 |4 | /
			//			  |------------|1 |__|
			//			  | 2  2  2  2 |1 | /
			//			  | 2  2  2  2 |__|
			//			  | 2  2  2  2 | /
			//			  |____________|


			//double (*p)[M][K]= dArray;


		for (int i = 0; i < N - 1; i += 2)
		{
			double(*p1)[K] = dArray[i];
			double(*p2)[K] = dArray[i + 1];
			//p1[1][2];

			for (int j = 0; j < M; j++) {
				for (int k = 0; k < K; k++) {
					//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
					double tmp = p1[j][k];
					p1[j][k] = p2[j][k];
					p2[j][k] = tmp;

					//Подсказки:
					//1) Слева от знака равенства надо определить два  сложных указателя.
					//Так как справа находятся "имена" слоев, т.е. двумерных массивов, то
					// остается вспомнить какой указатель является эквивалентным для имени двумерного массива.

					//2)дальше, воспользовавшись этими указателями, переставляем местами элементы i-того и i+1-ого слоев
				}
			}

		}
		stop
	}

	///////////////////////////////////////////////////////////////////////////
	
	//Задание 4
	//а) Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных
	//чисел таким образом, чтобы в массиве были только символы '_' и '*'

		//Подсказка 1: для генерации случайных чисел используйте функцию
		//стандартной библиотеки - rand() (<cstdlib>)
		//Можно с помощью генератора случайных чисел  и оператора % получать значения 0 и 1,
		// а в массив помещать соответственно '_' и '*'.

		srand(time(0));
	const int N=4,M=8;
	char Ar[N][M];

	for (int i=0;i<N;i++)
	{
		for (int j=0;j<M;j++)
		{
			Ar[i][j] = (rand()&1)?'*':'_';
			int R = rand()%2;
			if (R==0) {Ar[i][j]='*';}
			else {Ar[i][j]='_';}
			
		}

	}
	
	std::cout << "first" << std::endl;

	for (int i=0;i<N;i++)
	{
		for (int j=0;j<M;j++)
		{
			std::cout<<" "<<Ar[i][j];
		}
		std::cout<<"\n\n";
	}

	
	//char(*p)[M] = Ar;
	int count = 0;
	for (int i = 0; i < N; i++)
	{
		int count=0;
		for (int j = 0; j < M; j++)
		{
			
			if (Ar[i][j] == '*') {
				count++;
			}

		}
		for (int j = 0; j < count; j++)
		{
			
			Ar[i][j] = '*';

		}

		for (int j = count; j < M; j++)
		{

			Ar[i][j] = '_';

		}
	
	}
	

						
	


	std::cout << "sort first";
	std::cout << "\n\n";

	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			std::cout << " " << Ar[i][j];
		}
		std::cout << "\n\n";
	}
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			Ar[i][j] = (rand() & 1) ? '*' : '_';
			int R = rand() % 2;
			if (R == 0) { Ar[i][j] = '*'; }
			else { Ar[i][j] = '_'; }

		}

	}

	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			std::cout << " " << Ar[i][j];
		}
		std::cout << "\n\n";
	}
	std::cout << "\n\n";

	for (int j = 0; j < M; j++)
	{
		int k = N - 1;
		for (int i = N - 1; i >= 0; i--)//strings
		{
			if (Ar[i][j] == '*')
			{
				Ar[i][j] = '_';
				Ar[k][j] = '*';
				k--;
			}
		}
	}

	std::cout << "\n\n";
	std::cout << "sort second";
	std::cout << "\n\n";
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			std::cout << " " << Ar[i][j];
		}
		std::cout << "\n\n";
	}
		
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
		//чисел являются "псевдослучайными", то есть при двух последовательных запусках
		//приложения Вы получаете две одинаковые последовательности значений.
		//Для того чтобы генерируемые "случайные" значения были разными при каждом
		//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
		//и time() (<ctime>).
		//Функция srand() осуществляет "привязку" начала генерации к указанному в качестве параметра значению.
		//Функция time() задает эту точку отсчета, считывая текущее время
		//srand( time( 0 ) );

		//Замечание: в программе запускать функцию srand()  достаточно один раз


	//В каждой строке "сдвиньте звездочки" в начало строки, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив по строкам - "постройте распределение"




//for (int i = 0; i < N; i++)
//{
//	for (int j = 0; j < M; j++)
//	{
//		std::cout << " " << Ar[i][j];
//	}
//	std::cout << "\n\n";
//}


	// б) Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"

	///////////////////////////////////////////////////////////////
	//			Динамическое выделение памяти                    //
	///////////////////////////////////////////////////////////////
	//Задание 5.
		////Задание 5а.Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.

	srand(time(0));
	int N1, M1;
	N1 = 2 * 2;
	M1 = N1 * 2;
	
	int** p=new int* [N1];

	for (int i = 0; i < N1; i++)
	{
		p[i] = new int [M1];

	}
	for (int i = 0; i < N1; i++)
	{
	for (int j = 0; j < M1; j++)
	{
		
		p[i][j] = (rand() & 100);
	}
	
}

	for (int i = 0; i < N1; i++)
	{
		std::cout << "\n";
		for (int j = 0; j < M1; j++)
			std::cout << p[i][j] << " ," ;
	}
	std::cout << std::endl;
	std::cout <<"--------------------------" << std::endl;
	std::cout <<  std::endl;
		//Задание 5б. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"

	for (int i = 0; i < N1; i++)
	{
		int* pCur = p[i];//текущая строка
		for (int j = 0; j < M1 - 1; j++)
		{
			int* pMax = pCur;
			int* pTmp = pCur + 1;//pTmp перебор оставшихся эл-в
			for (int y = j + 1; y < M1; y++)
			{
				if (*pTmp > *pMax) pMax = pTmp;//если зн-е больше, перенапр-ся на pMax p.209 p.204-205
				pTmp++;//смещение на след. эл-т
			}

			int tmp = *pMax;//pMax, pCur меняются местами
			*pMax = *pCur;
			*pCur = tmp;
			pCur++;
		}

	}

	std::cout << std::endl;
	for (int i = 0; i < N1; i++)
	{
		std::cout << "\n";
		for (int j = 0; j < M1; j++)
			std::cout << p[i][j]<<" ,";
	}
		//Задание 5в. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива


		//Подсказка - не забудьте освободить память!
	int* aver = new int[N1];

	for (int i = 0; i < N1; i++)
	{
		int av = 0;
		for (int j = 0; j < M1; j++)
			av = av + p[i][j];
		aver[i] = av / M1;
	
	}
	std::cout << std::endl;
	std::cout << "--------------------------" << std::endl;
	std::cout << std::endl;
	for (int i = 0; i < N1; i++)
	{
	
			std::cout << aver[i] << " ,";
	}



	delete[] aver;

	for (int i = 0; i < N1; i++)
	{
		delete[] p;
		p = 0;
	}
	delete[] p;
	p = 0;


	/////////////////////////////////////////////////////////////////////////////
	//Задание 6. 
		//Реализуйте задание 2, используя не встроенные, а ДИНАМИЧЕСКИЕ массивы (массив?).
		// Важно! 
		//Так как строки могут быть разной длины, /эффективным решением было бы 
		//отводить под каждую строку ровно столько байтов, сколько требуется для ее хранения.
		//
		//Для того, чтобы определить длину введенной строки можно воспользоваться 
		//функцией strlen 
		//size_t strlen(char const* _Str);

		//При этом значение количества строк сформируйте с помощью потока ввода
	//int nStringNumber;

		//int strcmp(char const* _Str1, char const* _Str2);

//	

	//Цикл ввода строк:

	// Для ввода строки нужно использовать буфер "достаточного" размера. 
	// В качестве такого буфера обычно используется встроенный массив.
	// Для того, чтобы введенную строку  скопировать из буфера в массив  строк,
	// можно воспользоваться функцией strcpy
	//char* strcpy(	char* _Dest,  char const* _Source);
	//  или
	// 
	//errno_t strcpy_s(char* _Dest, size_t  _SizeInBytes, char const* _Source); 
	//где _SizeInBytes - размер "приемного" буфера _Dest
	
	//Замечание: 
	//скорее всего,если Вы используете strcpy, то при компиляции Вы получите следующую ошибку:
	//Severity	Code	Description	Project	File	Line	Suppression State
	//	Error	C4996	'strcpy': This function or variable may be unsafe.
	//Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.

	//Это происходит потому, что функция strcpy считается небезопасной.

	//Для того, чтобы пользоваться функцией strcpy, а не strcpy_s, можно
	//  - либо объявить макрос #define _CRT_SECURE_NO_WARNINGS   (обязательно ДО всех #include !!!!!)
	//- либо установить режим без доп. проверки на безопасность Properties->C/C++ ->General->SDL checs -> No


	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа



	int nStringNumber, number;
	char Tmp[80];
	const char stop_str[] = {"*"};
	std::cout << "\n Please, enter a number of string\n";
	std::cin >> nStringNumber;
	char** Str = new char* [nStringNumber]; // выделяется память под массив указателей p.219
	for (int i = 0; i < nStringNumber; i++)
	{
		std::cout << "\n Enter a sentence or '*'\n";
		std::cin >> Tmp;
		if (strcmp(Tmp, stop_str) == 0)
		{
			std::cout << "\nYou Entered 'stop_str' ";
			break;
			//NumI=i+1;
		}
		int Size = 0;
		Size = strlen(Tmp) + 1;
		Str[i] = new char[Size];
		strcpy(Str[i], Tmp);
		
		number = i + 1;
	}
	std::cout << "\n \nInput finished \n\n";
	std::cout << '\n';
	for (int i = 0; i < number; i++)
	{
		std::cout << Str[i];
		std::cout << '\n';
	}
	for (int i = 0; i < number; i++)
	{
		for (int j = 0; j < number - 1; j++)
		{
			if ((strcmp(Str[j], Str[j + 1])) > 0)
			{
				char* temp = Str[j];
				Str[j] = Str[j + 1];
				Str[j + 1] = temp;
			}
		}
	}
	std::cout << '\n';
	for (int i = 0; i < number; i++)
	{
		std::cout << Str[i];
		std::cout << '\n';
	}
	//освобождение памяти
	for (int i = 0; i < number; i++)
	{
		delete [] Str[i];
	}
	delete[] Str;
	//delete[] Stroka;//Освобождение занятой памяти 
	Str = 0;

	stop




	//Освобождение занятой памяти:

//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 7 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_7 (двумерный встроенный массив поля)_3.docx" и 
//*****************************************************************************************************


	//return 0;

}

