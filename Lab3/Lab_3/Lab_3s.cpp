/*************************************************************
	Практическое занятие №3. Директивы препроцессора.
							Указатели.
*************************************************************/




/*#define _USE_MATH_DEFINES
#include <math.h>
#include <cmath> 
#include <iostream> 
#include <tchar.h> 

#include "stdio.h"
*/


#include "stdafx.h"




#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку
using namespace std;
int _tmain()
{
	stop
	// ********************************************************
		//Задание 1. Директивы препроцессора

	 /*   #define LEN_ROUND(R) 2*R*M_PI;
		double R = 0;
		cout << "Inpur a radius circle R=:" << endl;
		cin >> R;
		double len = LEN_ROUND(R);
		cout << "Length circle equil : " << len << endl;

	*/

	//1.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
// *******************************************************



	//1.2.Макросы с параметрами.
	//1.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	/*
	{
		#define LENGHT(R) ((2.)*(R.)*M_PI);
		float l1 = LENGHT(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGHT(2); // должно быть 0.07957...
		cout << "Length circle equil : " << l1 << endl;
		cout << "Length circle equil : " << l2 << endl;
		stop
	}
	*/
	// *******************************************************

		//1.2.2 (B) определите макрос MAX(A, B)  для вычисления б'ольшего
		//значения из двух.
		/*
		#define MAX(A, B) (((A)-(B)>0) ? A : B);
	//#define MAX(A, B) (((A)-(B)>0) ? A : B);

		//Используйте макрос следующим образом. Следите за изменением
		//значений переменных k, i, j. Объясните результат.
		//Постарайтесь убрать побочные эффекты.
		//Отметьте случаи, когда избежать побочных эффектов невозможно

		int i = 10, j = 12, k;
		//k = MAX(i, j); 			//  i= 10  j= 12  k=12
	//	k = 2 * MAX(j, i);////  i= 10  j= 12  k=24
	//	k = MAX(j, i) * 2;		//  i= 10  j= 12  k=?  Программа пишет, что значок умножения-указатель. Поэтому выше переписано выражение.где сначала стоит двойка, а затем макрос.
	//	k = MAX(j, i+3);		//  i= 13, 10+3, j= 12     k=13
		k = MAX(i--, j++);		//  i= 9  j= 14  k=13    j=14 после операции ++, хотя неравенство в итоге решается верно  max = A-- >= B+++ ? A-- : B++; т.е. 9>13?9--:13++.  значения а и в равны 8 и 14 после ++
		*/
		// *******************************************************

			//1.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
			//двух объектов типа int в памяти местами. Проверьте для приведенного
			//фрагмента. Подумайте, что будет делать макроподстановка, если
			//переставляемые значения разного типа???
			//#define EXCHANGE(X, Y) double tmp = double(X); X = double(Y); double(Y) = tmp;

#define EXCHANGE(X, Y) { int tmp = (X); X = (Y); Y = tmp; }
//#define EXCHANGE(X, Y) ({ decltype(X) tmp = X; X = Y; Y = tmp; });

//	int x1=1, y1=-1;
	//EXCHANGE(x1,y1);

	//int x2 = 100, y2 = -100;
	//EXCHANGE(x2,y2);
	double x3 = 100.5;
	int y3 = -100;
	EXCHANGE(x3, y3);//потеря точности

	
		// *******************************************************


			//1.3. Директивы условной трансляции
			//Выполняя следующий фрагмент, посмотрите, какое
			//значение принимает переменная iNN. Что нужно сделать
			//для того, чтобы результат был равен 0? 1? 2?
		/*
		int iNN;
		#define NNN cout<<"macros";
		#define MMM cout<<"macros MMM";
		#if defined NNN && defined MMM
			iNN = 0;  //0 if defined NNN and MMM erlier
		#elif defined MMM
			iNN = 1;
		#elif defined NNN
			iNN = 2;//2 if defined NNN erlier

		#else
			iNN = -1;
		#endif

			stop

			*/
			// *******************************************************

				//Задание 1.4. Загляните в Project -> Properties -> диалоговая панель
				//- Property Pages -> C\C++  -> Preprocessor -> Preprocessor definitions.
				//В опциях командной строки в зависимости от мишени сборки проекта
				//(Debug или Release) может быть определено с помощью ключа /D
				//имя _DEBUG. С помощью директив условной
				//трансляции напишите фрагмент кода, который в зависимости от типа
				//мишени выводит с помощью cout разный текст на консоль. Проверьте
				//при разных мишенях сборки.

				//Пусть
				//для мишени Debug в процессе выполнения данного участка
				//кода на экран выводится информация об
				//имени файла, номере строки с функцией вывода, дате и времени 
				//компиляции файла, содержащего данную функцию вывода,
				//а также имя функции, содержащей данную строку.

				//Для мишени Release должна быть просто выведена строка
				//"Release configuration!"

				//Подсказка: для получения нужной информации зайдите в online справку
				//(Help -> View Help), выберете язык C++ и в поле поиска введите 
				//следующую ключевую фразу: Predefined Macros
				// Или пройдите по ссылке: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160



			/*


			#ifdef NDEBUG
			cout << "Release configuration!" << endl;

			#else
			//printf("%s\n", __LINE__);
			cout << __LINE__ << endl;//так работает LINE
				printf("%s\n", __FILE__);
			//	printf("%s\n", __LINE__);ошибка не знаю почему
				printf("%s\n", __TIME__);
				printf("%s\n", __DATE__);
				printf("%s\n", __func__);
			#endif


				*/

/*
				// *******************************************************
	{
		//Задание 1.5  Управляя определенностью идентификатора _UNICODE и используя
			//возможности заголовочного <tchar.h>, определим и проинициализируем переменную,
			//которая может становиться как однобайтовой, так и расширенной без 
			//изменения исходного текста.
			//С помощью отладчика проверьте результат (определите значение в 10-чной и 16-чной системе счисления).

		//Подсказка: Для того, чтобы настроить проект на работу с  некоторой кодировкой, надо:
			//1)Выбрать Project -> Properties. Будет открыта диалоговая панель  Property Pages  
			//2)Configuration Properties -> Advansed-> Advansed Properties -> Character Set
			//3) установить флаг "Use Unicode Character Set", если требуется Unicode
			//4) установить флаг "Not Set", если требуется  работа с однобайтовыми символами.
			// 
	//Замечание:  В следующие 4 строки не надо вносить никаких изменений, только добавить комментарии 
	// В комментариях указать значения кодов символов в 10-чной и 16-чной системе счисления




		TCHAR ch1 = __T('A');	// ch1=		ch1	65 'A'	wchar_t,  		ch1	0x0041 'A'	wchar_t


		size_t s1 = sizeof(ch1);// s1=? 		s1	0x00000002	unsigned int  2

		TCHAR ch2 = __T('Ф');	// ch2=		ch2	1060 'Ф'	wchar_t   		ch2	0x0424 'Ф'	wchar_t


		TCHAR ch3 = 'Ф';	// ch3=		ch3	0xffd4 'ￔ'	wchar_t	ch3	65492 'ￔ'	wchar_t

		ch3 = ch3;

	}

	*/



	// *******************************************************
	{
		//Задание 1.6
		//Создайте файл предкомпиляции.
		//Особого смысла в этой простой лаб. работе это не имеет.
		// Задание предлагается для знакомства с техникой создания файла предкомпиляции

		//В случае нашей лабораторной работы можно поместить директивы препроцессора, 
		//подключающие библиотечные файлы в отдельный заголовочный файл и создать файл предкомпиляции.
		//По умолчанию при создании нового проекта в Visual Studio в проекте указывается имя stdafx.h(VS 2019) 
		// в качестве имени файла предкомпилированного заголовка. Имя этого файла может быть изменено, но с целью упрощения мы этого делать не будем.
		//Надо выполнить несколько шагов :
		//1) Создать файл stdafx.h и поместить в него заголовки библиотечных файлов, которые будут использованы в работе
		//2) Создать файл реализации stdafx.cpp  и в него поместить единственную строку   #include "stdafx.h" 
		//3) В клиентском файле с исходным кодом подключить заголовочный файл stdafx.h
		//4) Задать ключи для файлов реализации :
		//		для stdafx.cpp - / Yc
		//		для lab3.cpp - / Yu


	}
	// ********************************************************
	// 
	/*
		//Задание 2.Заголовочные файлы. Директива #include
		//Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
		//В каждом заголовочном файле объявите перечисление с одинаковыми именами
		//констант, но сопоставьте именованным константам разные значения, например:
		//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
		//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
		//констант из 1.h, а в RELEASE-версии значениями констант из 2.h



		MyEnum::My1;
		cout << "My2 = " << My2 << '\n';


*/





	// ********************************************************
	
		//Задание 3. Указатели
		//Объявите  несколько объектов разных типов и проинициализируйте их.
		//Объявите указатели соответствующих типов и проинициализируйте их
		//адресами заданных объектов.
		//Выполняя задание, с помощью отладчика посмотрите, какие значения
		//будут присвоены переменным-указателям и на что эти указатели
		//"указывают"

		 int x = 2;
		char x2 = 'S';
		int * y = &x;//+		y	0x00b3fddc {0x00000002}	int *      /			0x72 'r'	char


		char * y2 = &x2;   //+		y2	0x00b3fdd3 "rММММММММ\x2"	char *   /			0x00000002	int





	
	// *******************************************************
	
		//Задание 4. Арифметика указателей. Операция разыменования указателя.
		//Выполняя задание, следите за изменением значений
		//указателей и значений объектов, на которые они указывают.
		//Интерпретируте наблюдаемые результаты
		{
			int nAr[3] = {1,3};//+		nAr	0x012ff8a8 {1, 3, 0}	int[3] массив

			int* pn = &nAr[0];//+		pn	0x012ff8a8 {1}	int * адрес нулевого элемента массива

			(*pn)++;//адрес не изменился.значение увеличилось на единицу
			pn++;//значение увеличилось на единицу -		pn	0x012ff8ac {3}	int *


			char cAr[]={'A','B','C','D'};//+		cAr	0x012ff890 "ABCD...	char[4]

			char* pc = &cAr[0];//-	адрсес нулевого элемента массива	pc	0x012ff890 "ABCDММММММММ¬ш/\x1ММММММММ\x2"	char */			65 'A'	char


			(*pc)=(*pc)+5;//		значение на которого указывает указатель изменилось	70 'F'	char

			pc=pc+3;//			68 'D'	char


			double dAr[3]={1.0,2.0};//
			double* pd1 = &dAr[0];//+		pd1	0x012ff864 {1.0000000000000000}	double *

			double* pd2 = pd1;//+		pd1	0x012ff864 {1.0000000000000000}	double *

			(*pd2)+=2;//+		pd1	0x012ff864 {3.0000000000000000}	double * значение стало равно 3

			pd2+=2;//+		pd2	0x012ff874 {0.0000000000000000}	double * изменился адрес на который указывает указатель.


			//Объясните результат выполнения операции
			//вычитания двух указателей
			pd1 = &dAr[0];			//=???-		pd1	0x012ff864 {3.0000000000000000}	double *

			pd2 = &dAr[1];			//=???+		pd2	0x012ff86c {2.0000000000000000}	double *

			int nNumber=pd2 - pd1;  //=1 значение переменной по адресу второго указателя минус значение переменной по адресу второго указателя

			//Сравните указатели pd2 и pd1 и с помощью cout
			//выведите результаты сравнения.
		//	cout << nNumber << endl;
		//	cout << sizeof(double) << endl;
		//	cout << sizeof(int)<< endl;

			stop
		}
	

	// *******************************************************
	
		//Задание 5. Void-указатель.
		//5.1. Выполняя задание, посмотрите - какие значения присваиваются
		//void-указателю. Обратите внимание: средствами отладчика Вы
		//не можете посмотреть значения, на которые "указывает"
		//void-указатель
		void*	pVoid;	//объявление void-указателя//		pVoid	0xcccccccc	void *

		int	nObject3=5;//		nObject3	0x00000005	int

		char cObject3='A';//		cObject3	65 'A'	char

		int*	pInt = &nObject3;// +		pInt	0x003afbf8 {5}	int *

		pVoid=&nObject3;//		pVoid	0x003afbf8	void *

		pVoid=&cObject3;//		pVoid	0x003afbef	void *

		pVoid= pInt;//		pVoid	0x003afbf8	void *


		//Прежде, чем раскомментировать следующую строчку, вспомните:
		//что нужно сделать, чтобы выражение стало корректным
		pInt= (int*)pVoid;


	// *******************************************************

		//5.2. При выполнении следующего фрагмента посмотрите, какие неприятности
		//могут Вас ожидать при явном приведении типа void-указателя,
		//который в момент времени (1) указывает на double, к типу
		//указателя на int (2)

		double dObject3 = 33.33;
		pVoid = &dObject3;	//(1)		pVoid	0x004ffb28	void *


		int nTmp = *(static_cast<int*>(pVoid) ); //(2)   = ???  		nTmp	0x70a3d70a	int//		nTmp	1889785610	int


		stop
	
	// *******************************************************

	
		//Задание 6.При выполнении задания обратите внимание на то,
		//как наглядно отладчик "раскрывает" конструкции типа
		//"указатель на указатель" и на способы получения конечного
		//объекта по таким "иерархическим" указателям
		int	n1=1;

		//Объявите указатель pn и проинициализируйте его так, чтобы он
		//"указывал" на n1
		int* pn = &n1;

		//Объявите указатель ppn и проинициализируйте его так, чтобы он
		//"указывал" на pn

		int* ppn = &(*pn);//+		ppn	0x0039f658 {1}	int *

		int **pp= &(pn);//+		+		pp	0x0039f64c {0x0039f658 {1}}	int * *


		int*** ppp = &(pp);//+		ppp	0x0039f634 {0x0039f64c {0x0039f658 {1}}}	int * * *


		//Объявите указатель pppn и проинициализируйте его так, чтобы он
		//"указывал" на ppn

		int* pppn = &(*ppn);
		//С помощью указателей pn, ppn и ppn получите значение объекта n1
		//и присвойте его n2

		int n2 = *pppn;//1
		int n3 = *ppn;//1
		int n4 = *** ppp;//1


		stop
	
	//*********************   Дополнительное задание   ****************************************************
	//Задание 7 (*)  
	// Выполните задание 2 по курсовой работе 
	// описание задания находится в файле "Задание (игра Змейка)_2 (змейка на экране)_3.docx"
	// Каждое задание выполняется в отдельном проекте
	// Рекомендация:
	// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
	//*****************************************************************************************************


	return 0;
}
//end main
